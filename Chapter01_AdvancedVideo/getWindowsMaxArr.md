# 生成窗口最大值数组
[完整代码](https://github.com/ludandandan/Programmer-interview-guide/blob/master/Chapter01_AdvancedVideo/getWindowsMaxArr.cpp)

## 介绍窗口和窗口内最大（小）值的更新结构
**窗口：**

 对于一个数组，有一个窗口在上面滑动。窗口有左边界L和右边界R框住，[L, R]范围为窗口内，L和R一开始停留在数组的最左边，R向右（R++）窗口内进数，L向右（L++）窗口内减数，L和R只能前进，不回退，并且L不能超过R。


**窗口内最大值的更新结构：**

若要随时得到窗口内框住的数的最大值或最小值，可以通过遍历窗口来得到，若窗口长度为w，那么时间复杂度就为O(w)，可以通过构建串口内最大值的更新结构，在窗口滑动的过程中记录当前窗口内的最大值和最小值，然后随时取出来的时间复杂度就为O(1)。

窗口内最大值的更新结构可以用双端队列来实现deque，需要包含头文件#include \<deque\>。

deq中放arr中的位置索引，头部到尾巴是arr[i]从大到小的。若要得到当前窗口的最大值，只需取出deq.front()看看即可。

当R向右移动，添加数arr[R]进窗口，此时检查deq中的尾部arr[i]是否小于等于当前数arr[R]，若是，那么就从deq的尾巴弹出数，直到不满足条件为止，然后把arr[R]添加到deq中。

当L向右移动，arr[L]出窗口，检查当前deq的头部i（位置索引）是否过期（即i是否小于等于L），若过期了，那么就把过期的从头部弹出来。

所有留在deq中的数，都是可能成为窗口最大值的数，所有当arr[R]与尾部数相等时也要弹出尾部，因为arr[R]虽然与尾部值相等，但是索引靠后，晚过期，所以之前的尾部就没必要留着了，就把他弹出来即可。

**题目：**

《程序员代码面试指南》p18

有一个整型数组arr和一个大小为w的窗口从数组的最左边滑动到最右边，窗口每次向右滑动一个位置。

例如数组为[4,3,5,4,3,3,6,7]，窗口大小为3时：

[4,3,5],4,3,3,6,7 窗口中最大值为5

4,[3,5,4],3,3,6,7 窗口中最大值为5

4,3,[5,4,3],3,6,7 窗口中最大值为5

4,3,5,[4,3,3],6,7 窗口中最大值为4

4,3,5,4,[3,3,6],7 窗口中最大值为6

4,3,5,4,3,[3,6,7] 窗口中最大值为7

如果数组长度为n，窗口大小为w，则共产生n-w+1个窗口的最大值

请实现一个函数：
1. 输入：整型数组arr，窗口大小w
2. 输出：一个长度为n-w+1的数组res， res[i]表示每一种窗口状态下的最大值。
   
以本题为例，应该返回[5,5,5,4,6,7]

**解析：**

这个题目直接应用了窗口内最大值的更新结构。只不过这个窗口是固定大小的，只需窗口的右边界r就可确定整个窗口的范围：当r\<w-1时，窗口的范围是[0, r]，当r\>=w-1时，窗口的范围是[r-w+1, r]。需要一个双端队列来构建窗口内最大值的更新结构，一个整型变量r表示窗口的右边界，当右边界到达数组最右边时就说明滑到头了，不用再求了。每次往双端队列里加数时先看看队列的尾巴是不是比现在的数小或者等于，若是就把他们弹出来，我们不再需要他们了，然后把现在的数放进去；否则就直接放进去。然后检查队列头部的数过期了（检查头部的数是否是不在窗口里了，窗口的范围是[r-w+1,r]所有若等于r-w就是不在窗口里了，不会是小于r-w的，因为每次r只变动一个，并且每次变动都会检查是否过期，若是小于r-w早就出去了，当然一开始还没形成窗口时不算），若过期了就把头部弹出来，然后现在的头部就是当前窗口的最大值，把它放到res里并令r++。一直循环到r到数组尾巴。

```c++
class getWindowsMaxArr{
public:
    vector<int> getArr(vector<int> arr, int w)
    {
        vector<int> res;
        if(arr.empty() || arr.size()<w) return res;

        deque<int> deq; //存窗口内最大值的索引
        int r=0; //窗口的右边界
        
        while(r<arr.size())
        {
            //窗口内进数,从头到尾是从大到小
            while(!deq.empty() && arr[deq.back()]<=arr[r])
            {
                deq.pop_back();//要是deq里的小就弹出来，弹弹弹，弹到死
            }
            //弹好了以后从尾巴进去
            deq.push_back(r);
            //检查deq的头部有无过期
            if(deq.front() == r-w) deq.pop_front();
            if(r>=w-1) res.push_back(arr[deq.front()]);
            r++;
        }
        return res;
    }
};
```
