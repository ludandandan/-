# 子数组异或和为0的最多划分
[完整代码](https://github.com/ludandandan/Programmer-interview-guide/blob/master/Chapter01_AdvancedVideo/mostEOR.cpp)

**题目：**

数组异或和的定义：把数组中所有数异或起来得到的值

给定一个整型数组arr，其中可能有正，有负，有零，你可以随意把整个数组切成若干个不相容的子数组，求异或和为0的子数组最多能有多少个？

**举例：**

arr = {3,2,1,9,0,7,0,2,1,3}

把数组分割成{3,2,1},{9},{0},{7},{0},{2,1,3}是最优分割，因为其中{3,2,1},{0},{0},{2,1,3}这四个数组异或和为0， 并且是所有分割方案中能切出最多异或和为0的子数字的方案，返回4

**要求：**

若arr长度为N，时间复杂度为O(N)


**解答：**

这种子数组的问题可以先考虑：依次求出必须以每个位置i结尾的情况下得到异或和为0的最优划分的子数组个数，最后求出必须以最后一个位置结尾的情况下得到异或和为0的最优划分的子数组个数就是答案。

在计算i位置时，会用到前面的信息，dp[i]表示如果在[0,..,i]上做分割，异或和为0的子数组最多能有多少个。

对以i作为结尾的数组进行划分，那么i肯定是作为最优划分的最后一部分的最后一个数字，那么就会有两种情况。
1. 最后一部分的异或和不为0.
    
    既然最后一部分的异或和不是0，那么dp[i] = dp[i-1]，即要或不要arr[i]都一样。
2. 最后一部分的异或和为0.
     
    既然最后一部分异或和为0，那么我们假设最后一部分是[k,...,i]那么dp[i] = dp[k-1]+1，要想是最优划分，k必须是里i最近的使异或和为0的数。假设[0,...,i]的异或和为sum，而[k,...,i]的异或和为0，那么[0,...,k-1]的异或和也是sum，我们要找[0,...,j]异或和为sum的里i最近的j，那么就是找出异或和为sum的最晚出现的位置（类比于之前求无序数组中累加和为给定值的最长子数组，是找累加和为sum的最早出现的位置）。同样，用一个map来记录每个sum出现的位置，有相同的sum出现时需要更新，因为是要求最晚出现的位置。

在上面这两种情况dp[i]=dp[i-1]和dp[i]=dp[k-1]+1里选较大的作为dp[i]


```c++
class solution{
public:
    int mostEOR(vector<int> arr)
    {
        if(arr.empty()) return 0;
        int sum = 0;//0异或任何数仍然是那个数
        map<int, int> m; //key表示异或和，value表示这个异或和出现的最晚的位置
        m.insert({0, -1});//先放进去一个打底的
        vector<int> dp(arr.size());
        dp[0] = 1;//只有一个数时只能划分为1个

        for(int i=1; i<arr.size(); i++)
        {
            sum = sum^arr[i];//当前的异或和
            dp[i] = dp[i-1];//这是一种情况
            if(m.count(sum)!=0)//若最后一部分可以异或和0
            {
                int k = m[sum];//k还有可能是-1，
                //这时候就说明sum=0,并且前面除了-1之外没有一个可以使异或和为0了，
                //也就是说最优划分是把0到i划分为一块，除此之外没有异或和为0的分割方式了
                int tmp = k==-1?1:(dp[k]+1);
                dp[i] = max(dp[i], tmp);
                //更新map
                m[sum] = i;
            }
            else
            {
                //更新sum
                m.insert({sum, i});
            }
        }
        return dp[arr.size()-1];
    }
};
```