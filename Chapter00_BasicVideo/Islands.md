## 岛问题
[完整代码](https://github.com/ludandandan/Programmer-interview-guide/blob/master/Chapter00_BasicVideo/Islands.cpp)

**题目：**
一个矩阵中只有0和1两种值，每个位置都可以和自己的上下左右四个位置相连。如果有一片1连在一起，这个部分角做一个岛，求一个矩阵中有几个岛。

> 这道题有两种规模。一种是矩阵比较小，单cpu就可以处理。一种是矩阵非常大，单cpu处理起来比较麻烦，需要考虑使用多个cpu并行计算。
> 1. 使用单cpu处理。使用深度优先搜索的方法。定义一个感染函数，在这个矩阵中用两个for循环遍历每一个点，如果这个点不是1就直接跳下一个，如果这个点是1那么就调用感染函数，（在这个函数中，从进入的那么点开始向上下左右感染它的相邻点，感染到的点从1变为2，以防重复感染），在主函数中调用一次感染函数（相当于进行一次深搜），岛的数量加1。当然在感染函数内部会自己调用自己，这个不用管岛的数量，进入感染函数后，若越界了（不在矩阵区域内）或点的值不是1，那么就直接返回，这时感染函数作为递归函数的终止条件。
> 2. 当矩阵非常大，需要使用多cpu并行处理时，用到了并查集的思想。需要先对矩阵进行分块，不同的块交给不同的cpu给处理，分别得到每个子块内岛的数量，这时就需要一个合并逻辑将每块的岛数量合并得到总的岛数量。以两个子块的一条边界为例子，合并逻辑只需要两个信息：一是要合并的子块的岛的数量；二是要合并的子块的边界信息。在每个子块上使用感染函数计算子块岛数量时，用字母标记每个岛的感染中心，也就是从哪里进到感染函数感染到整个岛的，将边界点的感染中心记录下来，感染中心相同的就相当于并查集中的代表节点相同，表示是一个集合。需要一个并查集，将不同子块的边界点及其各自的感染中心信息放到并查集里。对于两个相邻的子块。如果它的边界上的点的值是1（感染中心为A）对着1（感染中心是B），看看他们的感染中心属不属于同一个集合，用到并查集中查的功能，若属于同一个集合，不用管，若不属于同一个集合，那么就将着这两个点所在集合的感染中心变为同一个，应用并查集中的合并功能，合并之后两个子块岛数量之和减1。比如，第一次将感染中心为A的和B的合并了，第二次将A与C合并了，第三次遇到B与C时就知道他们在一个集合里了，不需要合并，岛的总数量也就不用减1了。多个子块可以两两合并再两两合并。

```c++
int islands(vector<vector<int>> m)
{
    if(m.empty() || m[0].empty()) return 0;
    int r = m.size();
    int c = m[0].size();
    int res = 0;
    for(int i=0; i<r; i++)
    {
        for(int j=0; j<c; j++)
        {
            if(m[i][j]==1)
            {
                infect(m, i, j, r, c);
                res++;
            }
        }
    }
    return res;
}

void infect(vector<vector<int>> &m, int i, int j, int r, int c)
{
    if(i<0 || i>=r || j<0 || j>=c || m[i][j]!=1) return;
    m[i][j] = 2;
    infect(m, i+1, j, r, c);
    infect(m, i-1, j, r, c);
    infect(m, i, j+1, r, c);
    infect(m, i, j-1, r, c);
}

```